<?php
/*
 * This file is part of the Mouf core package.
 *
 * (c) 2012 David Negrier <david@mouf-php.com>
 *
 * For the full copyright and license information, please view the LICENSE.txt
 * file that was distributed with this source code.
 */
namespace Mouf;

/**
 * This class is used to manage the config file "config.php" at the root of the project.
 * This file should only contain constants.
 * 
 * This class can be used to read and write from that file.
 *
 */
use Mouf\Reflection\MoufReflectionProxy;

class MoufConfigManager {

    const NO_ENV = 0;
    const FROM_ENV_WITH_FALLBACK = 1;
    const FROM_ENV_NO_FALLBACK = 2;

	private $constants = null;
	
	private $configFileName;
	
	/**
	 * The array containing the configuration constants in the form:
	 * 
	 * $constantsDef["variableName"] = array("defaultValue"=>"", "type"=>"string|int|float|bool", "comment"=>"some comment", "fetchFromEnv"=>0|1|2, "envName"=>"the environment variable to map to");
	 *
	 * @var array
	 */
	private $constantsDef = array();
	
	/**
	 * A list of constants name that have been undefined, and therefore, that should not be saved.
	 *
	 * @var array<string>
	 */
	private $undefinedConstants = array();
	
	/**
	 * Constructs the config manager with the name of the config file to write.
	 *
	 * @param string $configFileName
	 */
	public function __construct($configFileName) {
		$this->configFileName = $configFileName;
	}
	
	/**
	 * Returns the list of defined constants from config.php.
	 *
	 * @return array
	 */
	public function getDefinedConstants() {
		$this->loadConstantsIfNotLoaded();
		return $this->constants;
	}
	
	/**
	 * Loads the constant in the $constant var if they were not loaded.
	 *
	 */
	private function loadConstantsIfNotLoaded() {
		if ($this->constants == null) {
			$proxy = new MoufReflectionProxy();
			// TODO: really not very clean.
			// We need to move out of "selfedit" into a "managed dir" view of things.
			if ($this->configFileName == "../../../../../config.php") {
				$selfEdit = false;
			} else {
				$selfEdit = true;
			}
			$this->constants = $proxy->getConfigConstants($selfEdit);
		}	
	}
	
	/**
	 * Sets the constants to be defined by rewriting the config.php file.
	 *
	 * @param unknown_type $constants
	 */
	public function setDefinedConstants($constants) {
		$filePath = __DIR__."/".$this->configFileName;
		$dirPath = dirname($filePath);
		
		if ((!is_writable($dirPath) && !file_exists($filePath)) || (file_exists($filePath) && !is_writable($filePath))) {
			$dirname = realpath(dirname(__DIR__."/".$this->configFileName));
			$filename = basename(__DIR__."/".$this->configFileName);
			throw new MoufException("Error, unable to write file ".$dirname."/".$filename);
		}
		
		$this->constants = $constants;
		
		$fp = fopen($filePath, "w");
		fwrite($fp, "<?php\n");
		fwrite($fp, "/**\n");
		fwrite($fp, " * This is a file automatically generated by the Mouf framework. Do not put any code except 'define' operations\n");
		fwrite($fp, " * as it could be overwritten.\n");
		fwrite($fp, " * Instead, use the Mouf User Interface to set all your constants: http://[server]".ROOT_URL."mouf/config\n");
		fwrite($fp, " */\n");
		fwrite($fp, "\n");
		
		// Declare constants
		
		foreach ($this->getMergedConstants() as $key=>$def) {
			if (array_search($key, $this->undefinedConstants) === false) {
							
				if ($def['defined']) {
					if (isset($this->constants[$key])) {
						$value = $this->constants[$key];
					} else {
						$value = $def['defaultValue'];
					}
										
					if (trim($def['comment']) != "") {
						$commentArray = explode("\n", $def['comment']);
						$commentStr = "/**\n";
						foreach ($commentArray as $commentLine) {
							$commentStr .= " * ".$commentLine."\n";
						}
						$commentStr .= " */\n";
						fwrite($fp, $commentStr);
					}
                    $fetchFromEnv = isset($def['fetchFromEnv']) ? $def['fetchFromEnv'] : self::NO_ENV;
				} else {
				    $value = $this->constants[$key];
                    $fetchFromEnv = self::NO_ENV;
				}
				if ($fetchFromEnv == self::NO_ENV) {
                    fwrite($fp, "define(" . var_export($key, true) . ", ".var_export($value, true).");\n");
                } elseif ($fetchFromEnv === self::FROM_ENV_NO_FALLBACK) {
                    fwrite($fp, 'if (getenv(' . var_export($key, true) . ") === false) {
    throw new RuntimeException(\"The environment variable " . var_export($key, true) . ' must be set.");
}
');
                    fwrite($fp, "define(" . var_export($key, true) . ", ".var_export($value, true).");\n");
                } elseif ($fetchFromEnv == self::FROM_ENV_WITH_FALLBACK) {
                    fwrite($fp, "define(" . var_export($key, true) . ", getenv(".var_export($key, true).") !== false?getenv(".var_export($key, true)."):".var_export($value, true).");\n");
                } else {
				    throw new MoufException('Unexpected fetchFromEnv value: '.$fetchFromEnv);
                }
			}
		
		}
		
		fclose($fp);
		if (function_exists("opcache_invalidate")) {
			opcache_invalidate($filePath);
		}
	}

    /**
     * Registers a new constant.
     * Note: this will not set the value of the constant, just register it.
     *
     * @param string $name
     * @param string $type
     * @param string $defaultValue
     * @param string $comment
     * @param bool $fetchFromEnv
     * @param int $envName
     * @throws MoufException
     */
	public function registerConstant($name, $type, $defaultValue, $comment, $fetchFromEnv = true, $envName = null) {
		if ($type != "string" && $type != "int" && $type != "float" && $type != "bool") {
			throw new MoufException("Invalid type for constant. Must be one of: string|int|float|bool. Value passed: '".$type."'");
		}
		
		$this->constantsDef[$name] = array("defaultValue"=>$defaultValue, "type"=>$type, "comment"=>$comment, "fetchFromEnv"=>$fetchFromEnv);
		if (!empty($envName)) {
            $this->constantsDef[$name]['envName'] = $envName;
        }
	}
	
	/**
	 * Unregisters a constant.
	 *
	 * @param string $name
	 */
	public function unregisterConstant($name) {
		unset($this->constantsDef[$name]);
		$this->undefinedConstants[] = $name;
	}
	
	/**
	 * This function returns an array of all constants, with there attributes.
	 * It merges the constants definitions defined in MoufComponents and the constants defined in config.php.
	 *
	 * The returned values are in this format:
	 * $array["constantName"] = array("defaultValue"=>"", "type"=>"string|int|float|bool", "comment"=>"some comment", "value"=>"", "defined"=>true|false, "missinginconfigphp"=>true|notdefined, , "fetchFromEnv"=>true|false);
	 * 
	 * return array
	 */
	public function getMergedConstants() {
		$constantsInConfig = $this->getDefinedConstants();
		
		$finalArr = $this->constantsDef;
		
		foreach ($finalArr as $name => $constantDef) {
			if (isset($constantsInConfig[$name])) {
				$finalArr[$name]["value"] = $constantsInConfig[$name];
				unset($constantsInConfig[$name]);
			} else {
				$finalArr[$name]["missinginconfigphp"] = true;
			}
			$finalArr[$name]["defined"] = true;
		}
		
		// Now, let's add the defined constant that have no definition in MoufComponents
		foreach ($constantsInConfig as $name=>$value) {
			$finalArr[$name] = array("value"=>$value, "defined"=>false);
		}
		return $finalArr;
	}
	
	/**
	 * Returns the constant definition (as an array), or null if the constant definition is not defined.
	 *
	 * @param string $name
	 * @return array
	 */
	public function getConstantDefinition($name) {
		if (isset($this->constantsDef[$name])) {
			return $this->constantsDef[$name];
		} else {
			return null;
		}
	}
	
	/**
	 * Returns the array that will be written in MoufComponents.php.
	 *
	 * @return array
	 */
	public function getConstantsDefinitionArray() {
		return $this->constantsDef;
	}
	
	/**
	 * Sets the array of config description.
	 * 
	 * @param array $constantsDef
	 */
	public function setConstantsDefinitionArray($constantsDef) {
		$this->constantsDef = $constantsDef;
	}
}
